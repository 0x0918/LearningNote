# 线程

### 1. 有界·线程安全队列 ***BoundedBlockingQueue*** 
```cpp
    template<typename T>
    class BoundedBlockingQueue : boost::noncopyable {
    public:
        explicit 
        BoundedBlockingQueue(int maxSize) ;

        void put(const T& x) ;

        T take() ;

        bool empty() const ;

        bool full() const ;

        size_t size() const ;

        size_t capacity() const;

    private:
        mutable MutexLock          mutex_;
        Condition                  notEmpty_;
        Condition                  notFull_;
        boost::circular_buffer<T>  queue_;
    };
```
这个环形缓冲队列，有两个`条件量`:`notEmpty_`，`notFull_`。
+ `notEmpty_`：在`pull`函数完成任务添加后，通知执行任务`notEmpty_.notify()`。
+ `notFull_`：在`take()`函数执行完任务后，通知线程可以继续添加任务了`notFull_.notify()`。

这个类实现了线程安全的`queue`，内部封装了`Condition`、`Mutex`，使得完成任务可以内部有条不紊的进行。
### 2. 无界·线程安全队列 ***BlockingQueue***
由于无界，因此每次`put`添加数据时候不必考虑队列缓冲区是否满了。其余的大体和上面的有界线程安全队列一致。
```cpp
    template<typename T>
    class BlockingQueue : boost::noncopyable {
    public:
        explicit 
        BlockingQueue(int maxSize) ;

        void put(const T& x) ;

        T take() ;

        bool empty() const ;

        size_t size() const ;

        size_t capacity() const;

    private:
        mutable MutexLock          mutex_;
        Condition                  notEmpty_;
        std::deque<T>              queue_;
    };
```
###  3. 线程池  ***ThreadPool***
```cpp
    class ThreadPool : boost::noncopyable {
    public:
        typedef std::function<void ()> Task;

        explicit 
        ThreadPool(const string& name = string());
        ~ThreadPool();

        //启动线程数
        void start(int numThreads);
        void stop();
        void run(const Task& f);

    private:
        void runInThread();
        Task take();

        MutexLock mutex_;
        Condition cond_;
        string name_;
        boost::ptr_vector<muduo::Thread> threads_; 
        std::deque<Task> queue_; // 任务队列
        bool running_;
    };
```
+ 线程池的线程个数固定。
+ 线程执行流程  
    + 执行任务   
    `start`启动`numThreads`个数量的线程，并且创建的同时，执行`runThreads`函数，`runThreads`内部是通过`take()`来获取任务，如果此时任务队列为空，就会一直`wait`，等待任务的到来。
    + 添加任务  
    `run`函数作用是将任务添加到队列中，然后`notify`通知线程来执行任务。

### 4. 线程安全的单例类 ***Singleton***
+ `pthread_once`
    ```c
        #include<pthread>
        
        int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));
        
        pthread_once_t once_control = PTHREAD_ONCE_INIT;
    ```
这个函数`pthread_once`可以使得`init_routine`函数仅仅执行一次，而且是线程安全的，因此可以用来实现线程安全的单例类。
+ `atexit`
    ```c
       #include <stdlib.h>

       int atexit(void (*function)(void));
    ```
    可以注册一个函数，在**调用进程终止时**调用。对于单例类可以注册一个`destroy`函数，在进程退出时析构唯一的对象。

### 5. 线程特定数据 ***ThreadLocal***
即，每个线程都有这个变量，但是变量具体的值不同。对于`POD`数据类型，可以用`__thread`实现，对于非`POD`数据类型，需要借组**线程特定数据类型**实现一个类`ThreadLocal`。

