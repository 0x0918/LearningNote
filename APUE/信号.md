# 信号

#### 概念
信号是由于进程产生，但是由内核调度传递给另一个进程。
1. 产生信号
    + 按键产生信号:  
        + <font color=Crimson> `Ctr+c --> 2)SIGINT(终止/中断)`</font>   
        + <font color=Crimson> `Ctr+z --> 20)SIGTSTOP(终端暂停)` </font>   
        + <font color=Crimson> `Ctr+\ --> 3)SIGQUIT(退出)`</font>   
    + 系统调用产生: `kill(2), raise, abort`
    + 软件条件产生: 如定时器`alarm`
    + 硬件异常产生: 
        + 如非法访问内存(段错误): `11)SIGSEV(段错误)`
        + 除0: `8)SIGFPE`
    + 命令产生：`kill(1)`
2. 递达：产生的信号递达到了接受信号进程
3. 未决：介于产生信号和递达之间的状态，主要由于阻塞（屏蔽）导致。
4. 信号的处理方式
    + 默认：但是每个信号的默认动作可能不一致
        + Term: 终止进程
        + Ign : 忽略信号（默认即时对该种信号忽略操作）
        + Core: 终止进程，生成Core文件(查验进程死亡原因，用于gbd调试)
        + Stop: 停止（暂停）进程
        + Cnt : 继续运行进程
        + ***`9)SIGKILL、19)SIGSTOP`*** 不允许忽略和捕捉，只能执行默认动作。

    + 忽略：对于该信号的处理动作就是忽略
    + 捕捉：调用用户处理函数  
    
    
#### signal相关函数
##### <font color=Crimson>`1.kill`</font>  
```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```
+ 第一个参数：
    + pid > 0: 发送信号给指定的进程
    + pid = 0: 发送信号给与调用进程同一组的的所有进程，**而且发送进程有权向他们发送信号**
    + pid < 0: 将信号发送对应进程组ID=|pid|，**而且发送进程有权向他们发送信号**
    + pid =-1: 发送给这样的进程：**而且发送进程有权向他们发送信号**  
  
#####  <font color=Crimson>`2.raise/abort`</font> 
```c
// raise
#include <signal.h>
int raise(int sig);
// abort
#include <stdlib.h>
void abort(void);
```
+ raise : 自己给自己发信号
+ abort : 自己给自己发终止信号

##### <font color=Crimson>`3.alarm`</font>   
```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```
+ 设置定时器，在指定seconds之后，<font face='黑体' color=red>不管进程处于什么状态，时间一到就发送信号</font>。内核给当前进程发送是`14)SIGALRM`信号，进程收到该信号，默认动作是终止进程。
+ `seconds == 0`时，即取消定时器
+ 第一次设置定时器返回值0。后面再设置定时器时，会覆盖前面的定时器，重新计数，此时返回值是前面定时器剩余的秒数。
+ <font face="黑体" color=red>每个进程有且只有一个定时器。</font>

##### <font color=Crimson>`4.setitimer`</font> 
```c
#include <sys/time.h>

int getitimer(int which, struct itimerval *curr_value);
int setitimer(int which, const struct itimerval *new_value,
                         struct itimerval *old_value);

    struct itimerval {
        struct timeval it_interval; /* Interval for periodic timer */
        struct timeval it_value;    /* Time until next expiration */
    };

    struct timeval {
        time_t      tv_sec;         /* seconds */
        suseconds_t tv_usec;        /* microseconds */
    };
```

`setitimer` 相比较 `alarm` 提供了更加精确的定时信号控制，前者是微妙级，后者是秒级。
+ which
    + `ITIMER_REAL`&emsp;&ensp;: 等同于 `alarm`，自然定时，即和进行状态无关，时间到就发送`SIGALRM`
    + `ITIMER_VIRTUAL`: 计算进程占用cpu时间，发送信号`SIGVTALRM`
    + `ITIMER_PROF` &emsp;&ensp;: 计算进程cpu调用及执行系统调用时间，发送信号`SIGPROF`
+ `new_value/old_value`  
    + 前者是需要设置的时间，后者是返回的时间。
    + `setitimer` 是一个周期定时，`new_value`设置的本次和下次定时时间。当下次定时时间为0，就仅仅定时一次。